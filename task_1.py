# У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. 
# Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.
# Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

# Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, 
# і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. 
# Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. 
# Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

# # Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, 
# але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування 
# цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми 
# найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}

# Програмно реалізовано функцію, яка використовує принцип жадібного алгоритму. Код виконується і повертає словник 
# з кількістю монет кожного номіналу, що використовуються для формування певної суми. Спочатку вибираються найбільш 
# доступні номінали монет.

# На основі оцінювання часу виконання кожного з двох алгоритмів або О великого визначено найбільш ефективний при 
# великих сумах алгоритм.
# Зроблено висновки щодо ефективності алгоритмів для даного випадку. Висновки оформлено у вигляді файлу readme.md 
# домашнього завдання.

import timeit

# Жадібний алгоритм для видачі решти
def find_coins_greedy(amount):
    coins = [50, 25, 10, 5, 2, 1]
    result = {}
    
    for coin in coins:
        count = amount // coin
        if count > 0:
            result[coin] = count
            amount -= coin * count
    
    return result

# Динамічне програмування для видачі решти
def find_min_coins(amount):
    coins = [50, 25, 10, 5, 2, 1]
    min_coins = [float('inf')] * (amount + 1)
    min_coins[0] = 0
    coin_used = [0] * (amount + 1)
    
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                if min_coins[i - coin] + 1 < min_coins[i]:
                    min_coins[i] = min_coins[i - coin] + 1
                    coin_used[i] = coin

    result = {}
    while amount > 0:
        coin = coin_used[amount]
        if coin in result:
            result[coin] += 1
        else:
            result[coin] = 1
        amount -= coin

    return result

# Вимірювання часу виконання жадібного алгоритму
def measure_greedy_time():
    amount = 113
    time_taken = timeit.timeit(lambda: find_coins_greedy(amount), number=1000)
    print(f"Жадібний алгоритм: {time_taken:.6f} секунд")

# Вимірювання часу виконання алгоритму динамічного програмування
def measure_dynamic_time():
    amount = 113
    time_taken = timeit.timeit(lambda: find_min_coins(amount), number=1000)
    print(f"Алгоритм динамічного програмування: {time_taken:.6f} секунд")

# Виклик функцій для вимірювання часу
measure_greedy_time()
measure_dynamic_time()